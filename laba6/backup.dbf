создаем кошелек с паролем 1:
ALTER SYSTEM SET ENCRYPTION KEY IDENTIFIED BY "1";
C:\Users\user\admin\orcl\wallet

create table clients(id NUMBER GENERATED by default on null as IDENTITY PRIMARY KEY, name char(255), wallet char(255), password char(255));
insert ...

alter system set encryption wallet open IDENTIFIED by "1";
select * from clients;
alter system set encryption wallet close IDENTIFIED by "1";
select * from clients;


-------------------------tests:
ADMINISTER KEY MANAGEMENT CREATE KEYSTORE 'C:\Oracle\oracleKeys' IDENTIFIED BY "1234";
ADMINISTER KEY MANAGEMENT SET KEYSTORE OPEN IDENTIFIED BY "1234";
SELECT wrl_parameter,status FROM v$encryption_wallet;
-------------

CREATE DIRECTORY key_dir AS 'C:\Oracle\oracleKeys';
GRANT WRITE ON DIRECTORY key_dir TO sys;
GRANT READ ON DIRECTORY key_dir TO sys;
GRANT EXECUTE ON SYS.DBMS_CRYPTO TO public;

create or replace PROCEDURE add_client_wallet(input_string VARCHAR2) 
AS
  encrypted_raw RAW(2000);
  encryption_key RAW(2000);
  encryption_key_str VARCHAR2(16) := 'very_hard_key123';
  encryption_type PLS_INTEGER := DBMS_CRYPTO.ENCRYPT_AES128 + DBMS_CRYPTO.CHAIN_CBC + DBMS_CRYPTO.PAD_PKCS5;
BEGIN
  encryption_key := UTL_RAW.CAST_TO_RAW(encryption_key_str);
  encrypted_raw := DBMS_CRYPTO.ENCRYPT(UTL_I18N.STRING_TO_RAW(input_string, 'AL32UTF8'), encryption_type, encryption_key);
  INSERT INTO CLIENTS (WALLET) VALUES (encrypted_raw);
  
  DBMS_OUTPUT.PUT_LINE('Данные успешно зашифрованы');
END;

begin
add_client_wallet('new test value');
end;

create or replace PROCEDURE decrypt_client_wallet(client_wallet_id NUMBER) AS
  encrypted_raw RAW(2000);
  decryption_key RAW(2000);
  encryption_key_str VARCHAR2(16) := 'very_hard_key123';
  encryption_type PLS_INTEGER := DBMS_CRYPTO.ENCRYPT_AES128 + DBMS_CRYPTO.CHAIN_CBC + DBMS_CRYPTO.PAD_PKCS5;
  decrypted_raw RAW(2000);
  decrypted_string VARCHAR2(2000);
BEGIN
    SELECT WALLET INTO encrypted_raw FROM CLIENTS  WHERE id = client_wallet_id;
    DBMS_OUTPUT.PUT_LINE(encrypted_raw);
    
  decryption_key := UTL_RAW.CAST_TO_RAW(encryption_key_str);
  decrypted_raw := DBMS_CRYPTO.DECRYPT(encrypted_raw, encryption_type, decryption_key);

  decrypted_string := UTL_I18N.RAW_TO_CHAR(decrypted_raw, 'AL32UTF8');
  DBMS_OUTPUT.PUT_LINE(decrypted_string);

  UPDATE CLIENTS SET WALLET = decrypted_string WHERE id = client_wallet_id;
  DBMS_OUTPUT.PUT_LINE('Данные успешно дешифрованы');
END;

begin
    decrypt_client_wallet(23);
end;
-----------------------------------
4Е

create or replace PROCEDURE generate_prodedure_key(file_name VARCHAR2) AS
  key_raw RAW(16);
  fk1 UTL_FILE.FILE_TYPE;
BEGIN
  fk1 := UTL_FILE.FOPEN('KEY_DIR', file_name, 'wb', 16);
  key_raw := DBMS_CRYPTO.RANDOMBYTES(16);
  UTL_FILE.PUT_RAW(fk1, key_raw);
  UTL_FILE.FCLOSE(fk1);

  DBMS_OUTPUT.PUT_LINE('Сгенерированный ключ: ' || key_raw);
END;

create or replace PROCEDURE read_generated_key(file_name VARCHAR2, key OUT RAW) AS
  fk1 UTL_FILE.FILE_TYPE;
BEGIN
  fk1 := UTL_FILE.FOPEN('KEY_DIR', file_name, 'rb', 16);
  UTL_FILE.GET_RAW(fk1, key, DBMS_LOB.GETLENGTH(key));
  UTL_FILE.FCLOSE(fk1);
  DBMS_OUTPUT.PUT_LINE('прочитаный ключ:' || key);
END;



создаем папку для генерации ключа
CREATE DIRECTORY key_dir AS 'C:\Oracle\oracleKeys';

GRANT WRITE ON DIRECTORY key_dir TO public;
GRANT READ ON DIRECTORY key_dir TO public;

begin
generate_prodedure_key('client_wallet');
end;
Сгенерированный ключ: DA9CE0BD450CFD9645AB4547F369B088

begin
add_client_wallet_with_file_key('test wallet from file', 'client_wallet');
end;

create or replace PROCEDURE decrypt_client_wallet_with_file_key(client_wallet_id  NUMBER, key_file_name VARCHAR2) AS
  encrypted_raw RAW(2000);
  encryption_key RAW(16);
  encryption_type PLS_INTEGER := DBMS_CRYPTO.ENCRYPT_AES128 + DBMS_CRYPTO.CHAIN_CBC + DBMS_CRYPTO.PAD_PKCS5;
  decrypted_raw RAW(2000);
   decrypted_string VARCHAR2(2000);
BEGIN
  SELECT wallet INTO encrypted_raw FROM CLIENTS WHERE id = client_wallet_id;

  read_generated_key(key_file_name, encryption_key);

  decrypted_raw := DBMS_CRYPTO.DECRYPT(encrypted_raw, encryption_type, encryption_key);

  decrypted_string := UTL_I18N.RAW_TO_CHAR(decrypted_raw, 'AL32UTF8');
  DBMS_OUTPUT.PUT_LINE(decrypted_string);

  UPDATE CLIENTS SET wallet = decrypted_string WHERE id = client_wallet_id;
  DBMS_OUTPUT.PUT_LINE('Данные успешно дешифрованы');
END;

begin
decrypt_client_wallet_with_file_key(24, 'client_wallet');
end;

-----------------------------------------------------------
5E
cmd wrap iname=ADD_ENC.sql



-----------------------------------------------------------
6E

CREATE USER c##test_user IDENTIFIED BY 1 DEFAULT TABLESPACE users;

GRANT SELECT ANY TABLES TO c##test_user
/
GRANT SELECT ANY VIEW TO c##test_user
/
GRANT SELECT ANY PROCEDURE TO c##test_user
/
GRANT CREATE SESSION TO c##test_user;

GRANT SELECT on system.clients TO c##test_user
commit;
SELECT * FROM system.clients;

UPDATE system.clients SET name = 'test' WHERE id = 2;




audit create session;

AUDIT SESSION WHENEVER NOT SUCCESSFUL;

WITH FailedLogins AS (
    SELECT
        username,
        timestamp,
        LAG(timestamp) OVER (PARTITION BY username ORDER BY timestamp) AS prev_timestamp,
        LEAD(timestamp) OVER (PARTITION BY username ORDER BY timestamp) AS next_timestamp
    FROM dba_audit_session
    WHERE returncode <> 0
)

SELECT DISTINCT fl1.username
FROM FailedLogins fl1
WHERE (fl1.timestamp - fl1.prev_timestamp) <= 1
AND (fl1.next_timestamp - fl1.timestamp) <= 1;

NOAUDIT SESSION WHENEVER NOT SUCCESSFUL;

-----------------------------------------------------------
7E
create table very_security_log(id NUMBER GENERATED by default on null as IDENTITY PRIMARY KEY, username char(255), updatead_at timestamp)
create table very_security(id NUMBER GENERATED by default on null as IDENTITY PRIMARY KEY, name char(255), password char(255))

CREATE OR REPLACE PROCEDURE password_change_handler(object_schema varchar2, object_name varchar2, policy_name varchar2) IS 
BEGIN
       INSERT INTO very_security_log ( username, updatead_at) VALUES (
       USER,
       to_char(sysdate, 'dd-mm-yy hh24:mm:ss'));
END password_change_handler;


GRANT EXECUTE ON DBMS_FGA TO system;
GRANT AUDIT_VIEWER TO system;
commit;

BEGIN
  DBMS_FGA.ADD_POLICY (
    object_schema     => 'system',    
    object_name       => 'very_security',       
    policy_name       => 'very_security_policy',  
    audit_column      => 'password',   
    handler_schema    => 'system',
    handler_module    => 'password_change_handler',
    statement_types   => 'UPDATE',
    enable            => TRUE
  );
END;

-- обновляем very_security password, пишется запись very_security_log